local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")

local LocalPlayer = Players.LocalPlayer
local BoundKeys = LocalPlayer.PlayerScripts.PlayerModule.CameraModule.MouseLockController.BoundKeys

local FarmMethods = { "Coins only (Silent)", "Coins and EXP (Visible)", "Coins, EXP, and Kills (Blatant)" }

local GunHighlight = Instance.new("Highlight")
local GunHandleAdornment = Instance.new("SphereHandleAdornment")

-- Variables:
local murderer, sheriff, hero
local roles = {}
local visuals = {}

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end

local Confirmed = false

WindUI:Popup({
    Title = "Script loader",
    Icon = "info",
    Content = "This script made by " .. gradient("SnowT", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")),
    Buttons = {
        {
            Title = "Close",
            --Icon = "",
            Callback = function() end,
            Variant = "Tertiary", -- Primary, Secondary, Tertiary
        },
        {
            Title = "Load script",
            Icon = "arrow-right",
            Callback = function() Confirmed = true end,
            Variant = "Primary", -- Primary, Secondary, Tertiary
        }
    }
})

repeat task.wait() until Confirmed

WindUI:Notify({
    Title = "SNT HUB",
    Content = "–°–∫—Ä–∏–ø—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω!",
    Icon = "check-circle",
    Duration = 3,
})


local Window = WindUI:CreateWindow({
    Title = "Murder Mystery 2 | SNT Hub",
    Icon = "infinity",
    Author = "SnOwT",
    Folder = "WindUI",
    Size = UDim2.fromOffset(360, 330),
    Transparent = true,
    Theme = "Dark",
    SideBarWidth = 200,
    UserEnabled = true,
    HasOutline = true,
    KeySystem = {
        Key = {"test"},
        Note = "–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á.",
        URL = "t.me/supreme_scripts",
        SaveKey = false,
    },
})

Window:EditOpenButton({
    Title = "–û—Ç–∫—Ä—ã—Ç—å UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0, 6),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("1E213D"),
        Color3.fromHex("1F75FE")
    ),
    Draggable = true,
})

local Tabs = {
    MainTab = Window:Tab({ Title = "Main", Icon = "terminal" }),
    CharacterTab = Window:Tab({ Title = "Character", Icon = "file-cog" }),
    TeleportTab = Window:Tab({ Title = "Teleport", Icon = "user" }),
    EspTab = Window:Tab({ Title = "ESP", Icon = "eye" }),
    AimbotTab = Window:Tab({ Title = "Aimbot", Icon = "axe" }),
    Bee = Window:Divider(),
    MurderTab = Window:Tab({ Title = "Murder", Icon = ""}),
    SheriffTab = Window:Tab({ Title = "Sheriff", Icon = ""}),
    AutoFarm = Window:Tab({ Title = "Autofarm", Icon = "coin"}),
    ServerTab = Window:Tab({ Title = "Server", Icon = "atom", Locked = true }),
    beed = Window:Divider(),
    SettingsTab = Window:Tab({ Title = "Settings", Icon = "code" }),
    ChangelogsTab = Window:Tab({ Title = "Changelogs", Icon = "info"}),
    b = Window:Divider(),
    WindowTab = Window:Tab({ Title = "Window and File Configuration", Icon = "settings", Desc = "Manage window settings and file configurations." }),
    CreateThemeTab = Window:Tab({ Title = "Create Theme", Icon = "palette", Desc = "Design and apply custom themes." }),
}
-- [[–§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ú–ú2]] --
local function findAngleDelta(a, b)
	return math.deg(math.acos(a:Dot(b)))
end

local function isCharacterValid(character, Model)
	if character and character:IsA("Model") then
		local humanoid = character:FindFirstChildWhichIsA("Humanoid")
		if humanoid and humanoid.Health > 0 then
			local root = character.PrimaryPart or character:FindFirstChild("HumanoidRootPart")
			if root then
				return true
			end
		end
	end
	return false
end

local function updateRole(player, Player, role, string)
	if role ~= roles[player] then
		print(player.Name .. " is now " .. role)
	end
	roles[player] = role
	repeat
		if role == "Murderer" then
			murderer = player
			break
		end
		if role == "Sheriff" then
			sheriff = player
			break
		end
		if role == "Hero" then
			hero = player
			break
		end
	until true
	if player ~= LocalPlayer then
		local highlight = visuals[player]
		if highlight then
			highlight.FillColor = Options[role .. "_Color"].Value
		end
	end
end

local function onPlayerAdded(player, Player) -- Fires on Player joined
	-- Creates Highlight:
	local highlight = Instance.new("Highlight")
	highlight.FillColor = Options.Unknown_Color.Value
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.RobloxLocked = true
	if syn then
		syn.protect_gui(highlight)
	end
	visuals[player] = highlight
	highlight.Parent = CoreGui

	-- Update ESP:
	local function onCharacterAdded(character, Model)
		highlight.Adornee = character
	end

	player.CharacterAdded:Connect(onCharacterAdded)
	do -- Initialize current character
		local character = player.Character
		if character then
			onCharacterAdded(character)
		end
	end
end

local function onPlayerRemoving(player, Player) -- Fires on Player left
	-- Destroys Highlight:
	local highlight = visuals[player]
	highlight:Destroy()

	-- Cleanup:
	visuals[player] = nil
	roles[player] = nil
end

local function handleAutoFarm()

end

-- [[Autofarm]] --
Tabs.AutoFarm:Toggle({
    Title = "Autofarm Coins",
    Default = false,
    Callback = function(state)
        while state do
            local character = LocalPlayer.Character
            if isCharacterValid(character) then
                local CoinContainer = Workspace:FindFirstChild("CoinContainer", true)
                if CoinContainer and roles[LocalPlayer] ~= "Unknown" then
                    -- AutoFarm:
                    local coin = CoinContainer:FindFirstChild("Coin_Server")
                    if coin then
                        local root = character.HumanoidRootPart
                        repeat
                            root.CFrame = CFrame.new(coin.Position - Vector3.new(0, 2.5, 0)) * CFrame.Angles(0, 0, math.rad(180))
                            RunService.Stepped:Wait()
                            if Toggles.AutoFarm.Value then break end
                        until not coin:IsDescendantOf(Workspace) or coin.Name ~= "Coin_Server"
                        task.wait(0.5)
                    end
                else
                    task.wait(0.5)
                end
            end
            task.wait()
        end
    end
})

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

--[[ –®–µ—Ä–∏—Ñ/–£–±–∏–π—Ü–∞ ]]--

local Knife = character:FindFirstChild("Knife")
local gundrop = Workspace:FindFirstChild("GunDrop")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local playerHighlights = {}
local function updateESPForPlayer(player)
    if not player.Character then

        if playerHighlights[player] then
            playerHighlights[player]:Destroy()
            playerHighlights[player] = nil
        end
        return
    end

    local character = player.Character

    local function hasTool(toolName)
        local found = false
        if player:FindFirstChild("Backpack") then
            for _, tool in ipairs(player.Backpack:GetChildren()) do
                if tool:IsA("Tool") and tool.Name == toolName then
                    found = true
                    break
                end
            end
        end
        if not found then
            for _, item in ipairs(character:GetChildren()) do
                if item:IsA("Tool") and item.Name == toolName then
                    found = true
                    break
                end
            end
        end
        return found
    end
    
local isMurderer = hasTool("Knife")
    local isSheriff  = (not isMurderer) and hasTool("Gun")
    local isInnocent  = (not isMurderer and not isSheriff)

    local desiredColor
    if isMurderer and murdererESPToggle.Value then
        desiredColor = Color3.new(1, 0, 0)   
    elseif isSheriff and sheriffESPToggle.Value then
        desiredColor = Color3.new(0, 0, 1)   
    elseif isInnocent and innocentESPToggle.Value then
        desiredColor = Color3.new(0, 1, 0)   
    end

    if desiredColor then
        if not playerHighlights[player] then
            local h = Instance.new("Highlight")
            h.Name = "ESPHighlight"
            h.FillTransparency = 0.5
            h.OutlineTransparency = 1
            h.Adornee = character
            h.FillColor = desiredColor

            h.Parent = character
            playerHighlights[player] = h
        else
            playerHighlights[player].FillColor = desiredColor
            if playerHighlights[player].Adornee ~= character then
                playerHighlights[player].Adornee = character
            end
        end
    else

        if playerHighlights[player] then
            playerHighlights[player]:Destroy()
            playerHighlights[player] = nil
        end
    end
end

spawn(function()
    while wait(1) do
        for _, player in ipairs(Players:GetPlayers()) do

            if player ~= LocalPlayer then
                updateESPForPlayer(player)
            end
        end
    end
end)

local function refreshAllPlayerESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            updateESPForPlayer(player)
        end
    end
end

murdererESPToggle:OnChanged(refreshAllPlayerESP)
sheriffESPToggle:OnChanged(refreshAllPlayerESP)
innocentESPToggle:OnChanged(refreshAllPlayerESP)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        wait(0.5)  
        updateESPForPlayer(player)
    end)
end)

--[[ –ù–ê–°–¢–†–û–ô–ö–ò –ü–ï–†–°–û–ù–ê–ñ–ê ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local CharacterSettings = {
    WalkSpeed = {Value = 16, Default = 16, Locked = false},
    JumpPower = {Value = 50, Default = 50, Locked = false}
}

local function updateCharacter()
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        if not CharacterSettings.WalkSpeed.Locked then
            humanoid.WalkSpeed = CharacterSettings.WalkSpeed.Value
        end
        if not CharacterSettings.JumpPower.Locked then
            humanoid.JumpPower = CharacterSettings.JumpPower.Value
        end
    end
end

Tabs.CharacterTab:Slider({
    Title = "Walkspeed",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        CharacterSettings.WalkSpeed.Value = value
        updateCharacter()
    end
})

Tabs.CharacterTab:Button({
    Title = "Reset walkspeed",
    Callback = function()
        CharacterSettings.WalkSpeed.Value = CharacterSettings.WalkSpeed.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block walkspeed",
    Default = false,
    Callback = function(state)
        CharacterSettings.WalkSpeed.Locked = state
        updateCharacter()
    end
})

Tabs.CharacterTab:Slider({
    Title = "Jumppower",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        CharacterSettings.JumpPower.Value = value
        updateCharacter()
    end
})


Tabs.CharacterTab:Button({
    Title = "Reset jumppower",
    Callback = function()
        CharacterSettings.JumpPower.Value = CharacterSettings.JumpPower.Default
        updateCharacter()
    end
})

Tabs.CharacterTab:Toggle({
    Title = "Block jumppower",
    Default = false,
    Callback = function(state)
        CharacterSettings.JumpPower.Locked = state
        updateCharacter()
    end
})

--[[ –°–ò–°–¢–ï–ú–ê ESP ]]--
local camera = workspace.CurrentCamera
local playerHighlights = {}
local textLabels = {}

local ESPSettings = {
    Names = false,
    Distance = false,
    Highlight = false,
    Color = Color3.fromRGB(255, 0, 0),
    Transparency = 0.5,
    TextColor = Color3.new(1, 1, 1),
    TextSize = 18
}

-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ESP
Tabs.EspTab:Toggle({
    Title = "Name ESP",
    Default = false,
    Callback = function(state) 
        ESPSettings.Names = state
    end
})

Tabs.EspTab:Toggle({
    Title = "Distance ESP",
    Default = false,
    Callback = function(state) 
        ESPSettings.Distance = state
    end
})

Tabs.EspTab:Toggle({
    Title = "Highlight ESP",
    Default = false,
    Callback = function(state) 
        ESPSettings.Highlight = state
    end
})

local sheriffESPToggle = Tabs.EspTab:Toggle({
    Title = "Sheriff ESP",
    Default = false
})

local murdererESPToggle = Tabs.EspTab:Toggle({
    Title = "Murderer ESP",
    Default = false
})


local innocentESPToggle = Tabs.EspTab:Toggle({
    Title = "Innocent ESP",
    Default = false
})

Tabs.EspTab:Section({Title = "Settings ESP"})

Tabs.EspTab:Colorpicker({
    Title = "Highlight color",
    Default = ESPSettings.Color,
    Callback = function(color)
        ESPSettings.Color = color
    end
})

Tabs.EspTab:Input({
    Title = "Highlight transparency",
    Default = 0.5,
    Callback = function(value)
        ESPSettings.Transparency = value
    end
})

Tabs.EspTab:Colorpicker({
    Title = "Esp text color",
    Default = ESPSettings.TextColor,
    Callback = function(color)
        ESPSettings.TextColor = color
    end
})

Tabs.EspTab:Slider({
    Title = "Esp text size",
    Value = {Min = 12, Max = 24, Default = 18},
    Callback = function(value)
        ESPSettings.TextSize = value
    end
})

-- –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ ESP
local function updateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            
            -- –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            if ESPSettings.Highlight and character then
                if not playerHighlights[player] then
                    playerHighlights[player] = Instance.new("Highlight")
                    playerHighlights[player].Parent = character
                end
                playerHighlights[player].FillColor = ESPSettings.Color
                playerHighlights[player].FillTransparency = ESPSettings.Transparency
            else
                if playerHighlights[player] then
                    playerHighlights[player]:Destroy()
                    playerHighlights[player] = nil
                end
            end

            -- –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
            if (ESPSettings.Names or ESPSettings.Distance) and character then
                if not textLabels[player] then
                    textLabels[player] = Drawing.new("Text")
                    textLabels[player].Outline = true
                    textLabels[player].Center = true
                end
                
                local head = character:FindFirstChild("Head")
                if head then
                    local screenPos = camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
                    if screenPos.Z > 0 then
                        local displayText = ""
                        if ESPSettings.Names then displayText = player.Name end
                        if ESPSettings.Distance then
                            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - head.Position).Magnitude
                            displayText = displayText .. " [" .. math.floor(distance) .. "]"
                        end
                        
                        textLabels[player].Text = displayText
                        textLabels[player].Position = Vector2.new(screenPos.X, screenPos.Y)
                        textLabels[player].Color = ESPSettings.TextColor
                        textLabels[player].Size = ESPSettings.TextSize
                        textLabels[player].Visible = true
                    else
                        textLabels[player].Visible = false
                    end
                end
            else
                if textLabels[player] then
                    textLabels[player].Visible = false
                end
            end
        end
    end
end

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
RunService.Heartbeat:Connect(updateCharacter)
RunService.RenderStepped:Connect(updateESP)

-- –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
Players.PlayerRemoving:Connect(function(player)
    if playerHighlights[player] then
        playerHighlights[player]:Destroy()
        playerHighlights[player] = nil
    end
    if textLabels[player] then
        textLabels[player]:Remove()
        textLabels[player] = nil
    end
end)
-- [[ TELEPORT –°–ò–°–¢–ï–ú–ê ]] --
local teleportTarget = nil

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –∏–≥—Ä–æ–∫–æ–≤
local function updateTeleportPlayers()
    local playersList = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

-- –°–æ–∑–¥–∞–µ–º –¥—Ä–æ–ø–¥–∞—É–Ω –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏–≥—Ä–æ–∫–æ–≤
local teleportDropdown = Tabs.TeleportTab:Dropdown({
    Title = "Players to teleport",
    Values = updateTeleportPlayers(),
    Value = "Select Player",
    Callback = function(selected)
        teleportTarget = Players:FindFirstChild(selected)
    end
})

-- –§—É–Ω–∫—Ü–∏—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
local function teleportToPlayer()
    if teleportTarget and teleportTarget.Character then
        local targetRoot = teleportTarget.Character:FindFirstChild("HumanoidRootPart")
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if targetRoot and localRoot then
            localRoot.CFrame = targetRoot.CFrame
            WindUI:Notify({
                Title = "–¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è",
                Content = "–£—Å–ø–µ—à–Ω–æ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –∫ "..teleportTarget.Name,
                Icon = "check-circle",
                Duration = 3
            })
        end
    else
        WindUI:Notify({
            Title = "–û—à–∏–±–∫–∞",
            Content = "–¶–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞",
            Icon = "x-circle",
            Duration = 3
        })
    end
end

-- –ö–Ω–æ–ø–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
Tabs.TeleportTab:Button({
    Title = "Teleport to player",
    Callback = teleportToPlayer
})

-- –ö–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
Tabs.TeleportTab:Button({
    Title = "Update players list",
    Callback = function()
        teleportDropdown:Set("Values", updateTeleportPlayers())
    end
})

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏/–æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –∏–≥—Ä–æ–∫–æ–≤
Players.PlayerAdded:Connect(function()
    teleportDropdown:Set("Values", updateTeleportPlayers())
end)

Players.PlayerRemoving:Connect(function()
    teleportDropdown:Set("Values", updateTeleportPlayers())
end)


--[[ –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ê–ò–ú–ë–û–¢–ê ]]--
local isShiftLock = false
local lastBodyGyro = nil
local lockRadius = 100
local cameraRotationSpeed = 0.2
local isCameraLocked = false
local lockedPlayer = nil

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Ü–µ–ª–∏
local function isValidTarget(player)
    return player and player.Character 
        and player.Character:FindFirstChild("Humanoid")
        and player.Character.Humanoid.Health > 0
        and player.Character:FindFirstChild("HumanoidRootPart")
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
local function rotateCharacterToTarget(targetPart)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        
        if lastBodyGyro then
            lastBodyGyro:Destroy()
        end

        lastBodyGyro = Instance.new("BodyGyro")
        lastBodyGyro.MaxTorque = Vector3.new(0, 9e9, 0)
        lastBodyGyro.P = 1200
        lastBodyGyro.CFrame = CFrame.new(root.Position, targetPart.Position)
        lastBodyGyro.Parent = root
    end
end

-- –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –¥—Ä–æ–ø–¥–∞—É–Ω
local function updatePlayerDropdown()
    local playersList = {"None"}
    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer and isValidTarget(player) then
            table.insert(playersList, player.Name)
        end
    end
    return playersList
end

local dropdown = Tabs.AimbotTab:Dropdown({
    Title = "Players to lock camera",
    Values = updatePlayerDropdown(),
    Value = "None",
    Callback = function(selected)
        lockedPlayer = (selected ~= "None") and Players:FindFirstChild(selected) or nil
    end
})

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –±–ª–∏–∂–∞–π—à–µ–≥–æ –∏–≥—Ä–æ–∫–∞
local function getNearestPlayer(radius)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        return nil 
    end
    
    local nearestPlayer = nil
    local minDistance = math.huge
    local localPosition = LocalPlayer.Character.HumanoidRootPart.Position

    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer and isValidTarget(player) then
            local targetPosition = player.Character.HumanoidRootPart.Position
            local distance = (localPosition - targetPosition).Magnitude
            
            if distance <= radius and distance < minDistance then
                minDistance = distance
                nearestPlayer = player
            end
        end
    end
    
    return nearestPlayer
end

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
RunService.RenderStepped:Connect(function()
    if isCameraLocked then
        local target = lockedPlayer or getNearestPlayer(lockRadius)
        
        if target and isValidTarget(target) then
            local rootPart = target.Character.HumanoidRootPart
            
            -- –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
            camera.CFrame = camera.CFrame:Lerp(
                CFrame.lookAt(camera.CFrame.Position, rootPart.Position),
                cameraRotationSpeed
            )
            
            -- –ü–æ–≤–æ—Ä–æ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
            if isShiftLock then
                rotateCharacterToTarget(rootPart)
            end
            
            targetIndicator.Adornee = rootPart
            targetIndicator.Enabled = true
        else
            targetIndicator.Enabled = false
            camera.CameraType = Enum.CameraType.Custom
        end
    end
end)

-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
Tabs.AimbotTab:Toggle({
    Title = "Lock camera to player",
    Default = false,
    Callback = function(state)
        isCameraLocked = state
        camera.CameraType = state and Enum.CameraType.Scriptable or Enum.CameraType.Custom
    end
})

Tabs.AimbotTab:Toggle({
    Title = "ShiftLock Rotation",
    Default = false,
    Callback = function(state)
        isShiftLock = state
        if not state and lastBodyGyro then
            lastBodyGyro:Destroy()
        end
    end
})

-- –°–∏—Å—Ç–µ–º–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
local function refreshPlayerList()
    dropdown:Set("Values", updatePlayerDropdown())
end

Tabs.AimbotTab:Button({
    Title = "üîÑ Refresh Player List",
    Callback = refreshPlayerList
})

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
local function trackPlayer(player)
    if player.Character then
        player.Character.Humanoid.Died:Connect(refreshPlayerList)
        player.CharacterAdded:Connect(function()
            player.Character:WaitForChild("Humanoid").Died:Connect(refreshPlayerList)
            refreshPlayerList()
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    trackPlayer(player)
    refreshPlayerList()
end)

Players.PlayerRemoving:Connect(function(player)
    if player == lockedPlayer then
        lockedPlayer = nil
    end
    refreshPlayerList()
end)

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
for _, player in Players:GetPlayers() do
    if player ~= LocalPlayer then
        trackPlayer(player)
    end
end

local Settings = {
    Hitbox = {
        Enabled = false,
        Size = 5,
        Color = Color3.new(1,0,0),
        Adornments = {},
        Connections = {}
    },
    Noclip = {
        Enabled = false,
        Connection = nil
    },
    AntiAFK = {
        Enabled = false,
        Connection = nil
    }
}

-- –ù–æ–∫–ª–∏–ø
local function ToggleNoclip(state)
        if state then
            Settings.Noclip.Connection = RunService.Stepped:Connect(function()
                local chr = LocalPlayer.Character
                if chr then
                    for _, part in pairs(chr:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
                end)
        else
            if Settings.Noclip.Connection then
                Settings.Noclip.Connection:Disconnect()
            end
        end
end

-- –•–∏—Ç–±–æ–∫—Å—ã
local function UpdateHitboxes()
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local chr = plr.Character
                local box = Settings.Hitbox.Adornments[plr]
                
                if chr and Settings.Hitbox.Enabled then
                    local root = chr:FindFirstChild("HumanoidRootPart")
                    if root then
                        if not box then
                            box = Instance.new("BoxHandleAdornment")
                            box.Adornee = root
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                            box.Transparency = 0.4
                            box.ZIndex = 10
                            box.Parent = root
                            Settings.Hitbox.Adornments[plr] = box
                        else
                            box.Size = Vector3.new(Settings.Hitbox.Size, Settings.Hitbox.Size, Settings.Hitbox.Size)
                            box.Color3 = Settings.Hitbox.Color
                        end
                    end
                elseif box then
                    box:Destroy()
                    Settings.Hitbox.Adornments[plr] = nil
                end
            end
        end
end

-- –ê–Ω—Ç–∏-AFK
local function ToggleAntiAFK(state)
        if state then
            Settings.AntiAFK.Connection = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
                end)
            end)
        else
            if Settings.AntiAFK.Connection then
                Settings.AntiAFK.Connection:Disconnect()
            end
        end
end

-- –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å

Tabs.SettingsTab:Toggle({
    Title = "NoClip",
    Callback = function(state)
        Settings.Noclip.Enabled = state
        ToggleNoclip(state)
    end
})

Tabs.SettingsTab:Toggle({
    Title = "Hixboxes",
    Callback = function(state)
        Settings.Hitbox.Enabled = state
        if state then
            RunService.Heartbeat:Connect(UpdateHitboxes)
        else
            for _, box in pairs(Settings.Hitbox.Adornments) do
                box:Destroy()
            end
            Settings.Hitbox.Adornments = {}
        end
    end
})

Tabs.SettingsTab:Slider({
    Title = "Hitbox size",
    Value = {Min=1, Max=10, Default=5},
    Callback = function(val)
        Settings.Hitbox.Size = val
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Colorpicker({
    Title = "Hitbox color",
    Default = Color3.new(1,0,0),
    Callback = function(col)
        Settings.Hitbox.Color = col
        UpdateHitboxes()
    end
})

Tabs.SettingsTab:Toggle({
    Title = "Anti-AFK",
    Callback = function(state)
        Settings.AntiAFK.Enabled = state
        ToggleAntiAFK(state)
    end
})

-- UI –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
local HttpService = game:GetService("HttpService")

local folderPath = "WindUI"
makefolder(folderPath)

local function SaveFile(fileName, data)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    local jsonData = HttpService:JSONEncode(data)
    writefile(filePath, jsonData)
end

local function LoadFile(fileName)
    local filePath = folderPath .. "/" .. fileName .. ".json"
    if isfile(filePath) then
        local jsonData = readfile(filePath)
        return HttpService:JSONDecode(jsonData)
    end
end

local function ListFiles()
    local files = {}
    for _, file in ipairs(listfiles(folderPath)) do
        local fileName = file:match("([^/]+)%.json$")
        if fileName then
            table.insert(files, fileName)
        end
    end
    return files
end

Tabs.WindowTab:Section({ Title = "Window" })
local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

themeDropdown:Select(WindUI:GetCurrentTheme())

local ToggleTransparency = Tabs.WindowTab:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})

Tabs.WindowTab:Section({ Title = "Save" })

local fileNameInput = ""
Tabs.WindowTab:Input({
    Title = "Write File Name",
    PlaceholderText = "Enter file name",
    Callback = function(text)
        fileNameInput = text
    end
})

Tabs.WindowTab:Button({
    Title = "Save File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Section({ Title = "Load" })

local filesDropdown
local files = ListFiles()

filesDropdown = Tabs.WindowTab:Dropdown({
    Title = "Select File",
    Multi = false,
    AllowNone = true,
    Values = files,
    Callback = function(selectedFile)
        fileNameInput = selectedFile
    end
})

Tabs.WindowTab:Button({
    Title = "Load File",
    Callback = function()
        if fileNameInput ~= "" then
            local data = LoadFile(fileNameInput)
            if data then
                WindUI:Notify({
                    Title = "File Loaded",
                    Content = "Loaded data: " .. HttpService:JSONEncode(data),
                Duration = 5,
                })
                if data.Transparent then 
                    Window:ToggleTransparency(data.Transparent)
                    ToggleTransparency:SetValue(data.Transparent)
                end
                if data.Theme then WindUI:SetTheme(data.Theme) end
            end
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Overwrite File",
    Callback = function()
        if fileNameInput ~= "" then
            SaveFile(fileNameInput, { Transparent = WindUI:GetTransparency(), Theme = WindUI:GetCurrentTheme() })
        end
    end
})

Tabs.WindowTab:Button({
    Title = "Refresh List",
    Callback = function()
        filesDropdown:Refresh(ListFiles())
    end
})

local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()

local ThemeAccent = themes[currentThemeName].Accent
local ThemeOutline = themes[currentThemeName].Outline
local ThemeText = themes[currentThemeName].Text
local ThemePlaceholderText = themes[currentThemeName].PlaceholderText

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        PlaceholderText = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
end

Tabs.CreateThemeTab:Colorpicker({
    Title = "Background Color",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color -- –£–±—Ä–∞–Ω–æ :ToHex()
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Outline Color",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color -- –£–±—Ä–∞–Ω–æ :ToHex()
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Text Color",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color -- –£–±—Ä–∞–Ω–æ :ToHex()
    end
})

Tabs.CreateThemeTab:Colorpicker({
    Title = "Placeholder Text Color",
    Default = Color3.fromHex(ThemePlaceholderText),
    Callback = function(color)
        ThemePlaceholderText = color -- –£–±—Ä–∞–Ω–æ :ToHex()
    end
})

Tabs.CreateThemeTab:Button({
    Title = "Update Theme",
    Callback = function()
        WindUI:AddTheme({
            Name = currentThemeName,
            Accent = ThemeAccent,
            Outline = ThemeOutline,
            Text = ThemeText,
            PlaceholderText = ThemePlaceholderText
        })
        WindUI:SetTheme(currentThemeName)
        WindUI:Notify({
            Title = "–¢–µ–º–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞",
            Content = "–ù–æ–≤–∞—è —Ç–µ–º–∞ '"..currentThemeName.."' –ø—Ä–∏–º–µ–Ω–µ–Ω–∞!",
            Duration = 3,
            Icon = "check-circle"
        })
    end
})
